# Vue

## 历史

2014年初开源

vueRouter

vueresource

## 背景

* 旧的浏览器淘汰，移动端的需求增加，vue可以在移动端使用
* 前端交互越来越多，功能增加，游戏，交互，以及复杂的应用，包含购物，游戏，打车，音乐，视频，交互多
* 架构方式的变化，从传统后台的mvc到前端的mv*变化，所以我们需要一个框架来解决

## 特点

* 是一个轻量级的mvvm框架
* 数据驱动+组件化的前端开发方式
* 社区完善

## 应用场景

* 针对有复杂交互逻辑的应用
* 提供基础的架构抽象
* 通过ajax实现数据交互，保证前端的用户体验，只需要更新局部数据

## MVVM

Model 数据模型，就是js对象                 提供/保存数据

view      视图 （DOM）                           展示数据，提供用户界面

viewModel  通讯  观察者        

* Controller（数据处理，实现业务逻辑）                 


* View-Model：简化的 Controller，唯一作用就是为 View 提供处理好的数据，不含其他逻辑。

vue中的数据和视图不能直接通讯，要通过viewmodel，当视图变化，viewmodel知晓视图变化，同时通知数据变化，当数据变化的时候，viewmodel知晓数据变化，同时通知视图变化，这就是双向数据绑定

## 对比angular react

* vue更轻量
* 更容易上手，学习曲线比较平稳
* 吸收了两家所长，借鉴了angular的指令和react的组件化

## Vue的核心思想

如果没有mvvm框架，视图和数据是如何交互的？比如，我们通过ajax从后端获取数据，为了让视图改变，我们会手动触发DOM的改变，再比如，我们通过前端交互改变一些数据，为了让视图也发生变化，仍然需要手动触发DOM进行改变，但手动改变DOM不仅是一个繁琐的过程，还非常容易出错。

#### 数据驱动

##### 双向数据绑定

而我们用了vuejs后，就省去了手动操作DOM变化的步骤了，在vuejs里，你只需要改变数据，vuejs通过Directive（指令）去对DOM做一层封装，当数据发生变化，会通知指令去修改对应的DOM，数据驱动DOM变化，DOM是数据的一种自然映射，vuejs还会对一些操作做一些监听，当我们修改视图的时候，vuejs监听到这些变化，然后改变数据，这样也就形成了数据的双向绑定。

##### 数据响应原理

> 数据改变驱动视图自动更新

每一个vue对象实例化的时候，会对每一个数据添加getter和setter方法，同时，Vue.js会对模板做编译，解析生成一个的指令对象，每个指令都会关联一个watcher，当我们对某个数据值的时候，那么就会触发getter，把依赖收集到watcher里面。当我们改变值的时候，会触发setter，通知wacher，再次求值，然后对比新旧值，当发现值改变了，watcher就会通知到指令，调用指令的update方法，<u>因为指令是原生DOM的封装</u>，所以会调用原生DOM方法更新视图，这样就实现了从数据改变到视图自动更新的过程

![img](https://cn.vuejs.org/images/data.png)假设我们有数据对象a.b，在一个Vue对象实例化的过程中，会给a.b这个数据通过ES5的Object.defineProperty属性添加一个getter和setter方法，同时，Vue.js会对模板做编译，解析生成一个的指令对象，每个指令都会关联一个watcher，当我们获取a.b的值的时候，就会触发它的getter方法，把依赖收集到watcher里面。当改变a.b的值的时候，会触发setter方法，通知watcher，watcher会再次对a.b求值，计算对比新旧值，当发现值改变了，watcher就会通知到指令，调用指令的update方法。由于指令是对DOM的封装，所以它就会调用原生DOM方法去更新视图，这样就完成了从数据改变到视图自动更新的过程。



## 组件化

> 目的是扩展html元素，封装可以重用的代码          组件化的就近维护思想      

一个完整页面被分成不同的部分，一个部分对应一个组件

##### 组件的设计原则

* 页面的每一个独立的可视/可交互区域都可以视为一个组件
* 每个组件对应一个工程目录，组件所需要的各种资源在这个目录下就近维护，体现了前端自动化思想
* 页面不过是组件的容器，组件可以嵌套自由组合形成完整的页面

```js
npm install -g vue-cli --save
npm init webpack 012-ktv
```

### Vue-cli

> Vue-cli是Vue的脚手架工具，脚手架可以帮助我们编写好基础的代码

可以帮助搞定：

* 目录结构
* 本地调试
* 代码部署
* 热加载
* 单元测试

#### 安装过程

```
npm install -g @vue/cli
vue create webpack my-project
```

#### 项目文件介绍

![img](https://upload-images.jianshu.io/upload_images/5700710-cebf33ac17019737.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/650)





## 基础知识

#### 生命周期总结

| 生命周期函数    | 状态                       | 作用                                               |
| --------------- | -------------------------- | -------------------------------------------------- |
| `beforecreate`  | el和data并未初始化         | 可以在这加个loading事件                            |
| `created`       | 完成了data的初始化，el没有 | 在这结束loading，还做一些初始化，实现函数自执行    |
| `beforeMount`   | 完成了el和data的初始化     |                                                    |
| `mounted`       | 完成挂载                   | 在这发起后端请求，拿回数据，配合路由钩子做一些事情 |
| `beforeUpdate`  |                            |                                                    |
| `updated`       |                            |                                                    |
| `beforeDestory` |                            | 你确认删除XX吗？                                   |
| `destoryed`     |                            | 当前组件已被删除，清空相关内容                     |

#### computed 和methods

* 对于computed 和 methods 除了前者有缓存之外，完全一样
* 当依赖的响应式数据发生变化的时候，同时函数会重新运行计算值，computed属性也会重新进行计算
* 但是computed还有缓存，可以提高效率，不用多次重复计算

#### 数据传递

不要在子组件里面直接更改通过props传递过来的数据，如果有需要，通过$emit去触发，通过父组件去改变

在vuejs中规定data属性是个函数，因为组件是可以被复用的，定义成对象的话，如果你修改某一个组件的话，会影响另外组件，所以要定义成函数。 